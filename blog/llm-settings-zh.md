最近，我开始学习提示工程。我发现除了要学习怎么才能写一个好的prompt，不仅仅需要学习提示工程，还需要知道大语言模型可以调试什么参数。当我开始深入研究这个主题，我试着寻找一篇能很好的介绍LLM基础参数设置的文章。但在我看过的文章当中，很难找到一篇好的文章。有些文章讲的太浅，没能把这些概念讲清楚。我也读到过一些有深度的文章，可那些文章的信息太分散，很难让人形成一个整体的认知。因此，我决定自己来写一篇关于大语言模型的参数设置，稍微有深度又利于大家理解的文章。

我会在这篇文章里介绍这些参数： **Temperature**, **TOP-P**, **Max Length**, **Stop Sequence**, **Frequency Penalty**, 和 **Presence Penalty**。 

# ** Token

Token是LLM可以理解的最小单位。 一个Token可以是一个词，一个标点符号，甚至是一个空格。有意思的是，一个token有可能没有自己的**独立的意义**。

我们可以用openai的这个网站来测试模型：
https://platform.openai.com/tokenizer

假设我们现在在LLM里输入 "**Hello there, my friend\!**"，AI会把这个句子分解成下边几个Token:

![sentence_to_token](assets/llm_setting_img1.png)

我们可以注意到有些Token，比如说 **" there"** 和 **" my"**，他们的前缀是个空格。这是因为AI的标记器（tokenizer）一开始就是被设计成了用空格分词， 而这样的token可以帮助LLM理解文字的意思。

让我们再来看一个例子:

"**unbelievable**"。虽然这是一个词，但这个词会被模型分解成好几个token:

* **"un"**  
* **"bel"**  
* **"ievable"**

![sentence_to_token_2](assets/llm_setting_img2.png)

这种把一个单词分解成多个Token的方式， 能让AI更好的处理比较长的组合单词。

总之，我们可以把Token理解为AI模型**观察**和**理解**语言的方式。一个模型支持的所有Token大体上就是他的字母表和词汇表的结合体。

还值得一提的是，每个模型在训练之后，会有固定能够理解和处理的Token数量。这个东西叫做词汇表(Vocabulary)。词汇表越大，模型能够理解和使用的词汇就越多。 以llama 为例， Llama 2 的词汇表大小是 3.2 万，而 Llama 3 的词汇表大小是 12.8 万。

## TokenID（token ID）

从技术层面讲，AI会为每个Token（token）分配一个数字。这个数字ID和token是完全1对1对应的。由于计算机计算数字的速度远远大于文字的速度，所以转化成数字可以大幅提高运算效率。

让我门来举个简单的例子，如果我们有个句， "**Hello there, my friend\!**"
AI会先把句子分解成: "Hello", " there", ",", " my", " friend", "\!".

然后根据预设的数字映射，给每个Token一个完全唯一的数字ID。这整个过程叫做**tokenization**。

![token_id](assets/llm_setting_img3.png)


# 温度 （Temperature）

对于AI来说， **温度**是它在生成文本时的**随机**程度。 

### 低温度 (可预测且基于事实)
当温度较低时，AI会偏向于选择更可能出现的下一个token。当温度降到0的时候，对于相同的query，AI会给完全相同的的答案。

当我们需要AI做具体的工作的时候，使用低温会比较适合。而对于0温度，常常在工程上会把测试的温度调成0，这样有助于产生稳定的测试结果。

### 高温度 (富有创造力且多样化)
当温度较高时，AI可选择的token范围会变广。这个时候AI会更有可能选择可能性比较低的token，从而让AI的输出有更多随机性和多样性。 这就好比一个创意作家为了他的作品在进行头脑风暴的时候，他不会仅仅选择简单明了的词汇；也有可能会考虑许多不同的选项，以寻找独特而有趣的东西。

调高温度最适合于让AI执行创意相关的任务，例如写诗、创作故事。

### 温度的计算方式

当模型得到每个词的概率之前，每个词的概率会先用一个数字表示。这个数字叫做logit。通常这个数字越大，AI选择这个词的可能性就越大，最后转化成概率后的概率就越高。

如果这个时候用每个数字都**除以**一个参数，那这个参数越大的时候，词与词之间的**距离**就会变小

比如说，我们给AI这个query
`I like eat fruits，I want to eat a`

然后AI最终得到这个词单
Output, logit
Apple , 100
pear  , 70
cherry, 10
kiwi  , 0

假设temperature是0.5的时候，转化后的值是：
Output, logit/temperature
Apple , 100 / 0.5 = 200
pear  , 70 / 0.5 = 140
cherry, 10 / 0.5 = 20
kiwi  , 0 / 0.5  = 0

这些数字会被丢到softmax函数里计算概率分布
![token_id](assets/softmax_formula.png)

计算出来的结果会形成这样的分布
![token_id](assets/temperature_distribution.png)

所以结论就是：
温度越大，词与词之间的概率分布越平均，温度越小，词与词之间的概率分布就越分散。


### 例子

当我们给AI输入：“天空为什么是蓝色的？”

如果这时候AI配置的温度较低时，AI会给出下边的预测结果

- 瑞利散射 (95%)
- 光 (2%)
- 反射 (1%)
- 吸收 (1%)
- 某个东西 (0.5%)

AI会有95%可能性选择 “瑞利散射”， 所以有95%的概率会生成：“天空之所以是蓝色的，是因为一个被称为瑞利散射的过程。” 这个句子。

然而，当温度较高时， 输出的词的可能性就会变得靠近：
- 瑞利散射 (60%)
- 光 (15%)
- 反射 (10%)
- 太阳光 (5%)
- 大气的 (5%)


所以现在只有60%的概率AI会生成- “天空之所以是蓝色的，是因为一个被称为瑞利散射的过程。”， 而选择其他词的可能性也大了很多。

# TOP-P
TOP-P，也称为原子核采样 (nucleus sampling)，是另一种控制AI在生成文本时创造力的方式。温度会改变每个可能出现的下一个词语的概率，而TOP-P则专注于将选择范围缩小到最可能的那些词语。

## TOP-P 的工作原理

现在我门来聊聊TOP-P。每次AI生成下一个词的时候，AI都会先生成一个可能的下一个词语的列表，表里的每个词语都有其被选中的概率。使用TOP-P时，AI只会考虑列表顶部的词语，直到它们的**累积概率**达到某个设定的百分比。

**低 TOP-P：** 假设我们把TOP-P设置为10%。AI只会查看累积概率达到10%的最可能的词语。这使得AI从一个非常小且确定的词语组中进行选择。输出将非常安全且基于事实。

**高 TOP-P：** 如果您将TOP-P设置为90%，AI会从列表顶部考虑一个更大的词语组，其中包含许多可能性较低的词语。这给了AI更多的选择，从而产生更多样化和创造性的输出。

### 例子
我们用和刚刚一样的例子来理解下TOP-P：“天空为什么是蓝色的？”
这时候假设温度是0.8 那AI可能产生的下一个词语是：

- 瑞利散射 (60%)
- 光 (15%)
- 反射 (10%)
- 太阳光 (5%)
- 大气的 (5%)

...

用这个概率分布，我们可以得到以下累积概率：

- 瑞利散射 (60%) => 累积概率 60%
- 光 (15) => 累积概率 75%
- 反射 (10%) => 累积概率 85%
- 太阳光 (5%) => 累积概率 90%
- 大气的 (5%) => 累积概率 95%

...

假设我们设置了一个低的TOP-P（0.3）。在这种情况下，AI只会选择“瑞利散射”这个词，因为它的累积概率是60%。

但当我们设置一个高的TOP-P（0.9）时，AI会考虑所有直到“太阳光”的词语，因为它们的累积概率（60% + 15% + 10% + 5% = 90%）低于90%的阈值。输出可能是“瑞利散射”、“光”、“反射”或“太阳光”。

### TOP-P 与温度的区别
TOP-P和温度的主要区别在于它们影响词语选择的方式。

温度改变了所有可能出现的词语的概率。它使不太可能的词语变得更有可能，而最可能的词语变得不那么可能。

TOP-P完全移除了那些最不可能的词语的考虑。这就像在最可能的选项后边画一条一个分界线，并告诉AI只在这个范围内进行选择。

由于这两种控制都旨在调整AI的创造力，通常建议一次只调整其中一个以获得最佳结果。

# TOP-K 
有些LLM还会有另一个参数叫做TOP-K。和TOP-P相似，这个是让LLM之选择前K个概率最高的token。

# 最大长度 (Max Length)
最大长度参数用于控制模型生成的词语（token）的数量。当模型达到此参数的限制时，它将立即停止生成更多词语。

值得注意的是，在现阶段，大语言模型还不够智能， 没法根据最大长度限制动态调整生成token数量；这个只能在达到最大值后简单地停止生成词语。

因此，这个参数这可能导致大语言模型输出不完整的句子或短语。

例如，如果模型要生成这个句子：

"The quick brown fox jumps over the lazy dog." 

...如果我们把max length设成5，输出就会变成：

"The quick brown fox jumps"

### 这个参数有什么用？

我们需要这个参数是因为模型可能会“幻觉循环” (The Hallucination Loop)，然后模型会无限地生成无意义或重复的内容。所以，如果我们能设置一个合理的“最大长度”值，可以帮助我们确保在限制内得到正常输出，并消除提示生成大规模、非预期响应的风险。

# 停止序列 (Stop sequence)
停止序列是另一种控制模型何时停止输出的方式。与硬性限制不同，停止序列会在模型输出特定模式时停止。这不仅能让我们对模型输出进行更精细的控制，还可以防止模型在结构化数据之后添加额外的评论或叙述，特别对于需要固定解析代码的场合。

## 停止序列的潜在运用
以下是停止序列的一些常见用例：

* JSON 或 XML: 当要求模型生成一个JSON对象时，我们可以将停止序列设置为闭合标签，例如}或</xml>。
* 代码生成: 当要求LLM生成代码片段时，您可以使用像```这样的停止序列来确保它在代码块之后停止。
* 列表和项目符号: 如果我们想要一个特定项目数量的列表，我们可以使用停止序列来控制。例如，如果您想要一个包含10个项目的列表，您可以使用 "11." 作为停止序列。
* 对话系统: 在多轮聊天或对话中，我们可以使用另一方的名字作为停止序列（例如，User: 或 Customer:）。这会告诉模型停止为一方生成响应，并等待下一轮，从而防止它扮演另一方的角色。

# 频率惩罚 (Frequency Penalty)
频率惩罚会根据一个Token已经出现的次数来阻止模型重复使用这个Token。我们可以把这个参数想象成一种累积惩罚：
`一个词语被使用的次数越多，它再次被选中的可能性就越低。`

模型会为每个可能的下一个词语分配一个数值，称为对数几率 (logit)。较高的对数几率分数意味着这个词语更有可能被选中。频率惩罚通过每次使用一个词语时降低它的对数几率分数来起作用。惩罚会应用于词语的每一次出现，因此一个出现过三次的词语会比只出现过一次的词语受到更重的惩罚。这个功能特别有用，当您希望允许一些常用词语的重复，但又要防止某个特定词语被过度使用时。

假设模型最初想要生成这个句子：

The cat sat on the mat, and the dog barked at the cat, which then ran away from the cat.
（这只猫坐在垫子上，狗冲着这只猫叫，然后这只猫跑开了。）

如果我们对对“猫”（cat）设置了频率惩罚，可能会发生以下情况：

第一次出现： 模型使用了“猫”。“猫”的惩罚开始累积。

第二次出现： 模型想再次使用“猫”。现在惩罚被应用了，但很小，所以“猫”这个词仍然是一个高概率的选择。模型再次选择了“猫”。

第三次出现： 模型现在考虑第三次使用“猫”。惩罚已经累积，使得这个词语的概率显著降低。模型现在选择了一个同义词，比如“它”，以避免强烈的惩罚。

这产生了一个显示惩罚增加效果的输出：

The cat sat on the mat, and the dog barked at the cat, which then ran away from it.
（这只猫坐在垫子上，狗冲着这只猫叫，然后它跑开了。）

# 存在惩罚 (Presence Penalty)

另一方面，存在惩罚会阻止模型在一个词语第一次出现后再次使用它。这种惩罚是一次性扣除。一旦一个词语被使用过，它的对数几率分数就会被降低，并且无论之后这个词语被使用了多少次，惩罚都会保持不变。

与频率惩罚类似，存在惩罚会降低一个词语的对数几率分数。然而，这种降低只在词语第一次被生成时发生一次。这使其成为一个强大的工具，用于鼓励更广泛的词汇量，并防止任何一个词语被重复，无论它被使用了多少次。

让我们使用相同的例子：

The cat sat on the mat, and the dog barked at the cat, which then ran away from the cat.
（这只猫坐在垫子上，狗冲着这只猫叫，然后这只猫跑开了。）

对“猫”（cat）这个词应用存在惩罚时，可能会发生以下情况：

第一次出现： 模型使用了“猫”。一个显著的、一次性的惩罚立即应用于“猫”这个词，使其再次被选中的可能性变得极低。

第二次出现： 模型想再次使用“猫”。存在惩罚已经应用，使得像“它”或同义词“猫科动物”这样的词语更有可能。模型选择了“它”。

第三次出现： “猫”这个词已经使用过，并且仍然受到第一次使用时所施加的相同的高额惩罚。它再次被选中的可能性非常低。

这产生了模型更简洁、更多样化的输出：

The cat sat on the mat, and the dog barked at it, which then ran away from the feline.
（这只猫坐在垫子上，狗冲着它叫，然后这只猫科动物跑开了。）

# 主要区别与总结
两者之间的核心区别在于它们的累积性。频率惩罚就像是随着每一次违规而增加的累积罚款，而存在惩罚则是一次性的永久罚款。

频率惩罚按出现次数进行惩罚，非常适合减少过度重复。

存在惩罚按词语进行惩罚，是一种更激进的方式，可以鼓励多样化的词汇。

在实践中， 一般建议只使用频率惩罚或存在惩罚，而不要同时使用。

# 总结
通过对这些核心参数的清晰理解，在prompt engineering的基础上，我们可以更好的控制AI的行为。。对于prompt engineering来说，有时候如果发现问题很难调整提示词修复，不妨试试看调整这些参数，也许可以收到意想不到的效果。
